---
title: "IRE1a_poly_only_2023"
output: html_document
date: "2023-08-30"
---



```{r setup}

setwd("~/My Drive/Bench/IRE1 Polysome Seq 2022/")

library(data.table)
library(GenomicFeatures)
library(tximport)
library(DESeq2)
library(apeglm)
library(ggplot2)
library(ggrepel)
library(EnhancedVolcano)
library(rnaseqDTU)

```



###  METADATA
```{r metadata}
# Create metadata # WT_total_se_4 and IRE1aKO_total_se_3 are outliers and removed
metadata = data.frame(
  sample_id = c("IRE1aKO_poly_1", "IRE1aKO_poly_2", # IRE1aKO first polysome samples (batch 2)
                "IRE1aKO_poly_3.1", "IRE1aKO_poly_3.2", # IRE1aKO polysome heavy & light merged , sample 1, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_4.1", "IRE1aKO_poly_4.2", # IRE1aKO polysome heavy & light merged , sample 2 technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_5.1", "IRE1aKO_poly_5.2", # IRE1aKO polysome heavy & light merged , sample 3 technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_heavy_1.1", "IRE1aKO_poly_heavy_1.2", # IRE1aKO polysome heavy sample 1, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_heavy_2.1", "IRE1aKO_poly_heavy_2.2", # IRE1aKO polysome heavy sample 2, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_heavy_3.1", "IRE1aKO_poly_heavy_3.2", # IRE1aKO polysome heavy sample 3, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_light_1.1" ,"IRE1aKO_poly_light_1.2" , # IRE1aKO polysome light sample 1, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_light_2.1" ,"IRE1aKO_poly_light_2.2" , # IRE1aKO polysome light sample 2, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_light_3.1", "IRE1aKO_poly_light_3.2", # IRE1aKO polysome light sample 3, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_total_se_1","IRE1aKO_total_se_2","IRE1aKO_total_se_3", "IRE1aKO_total_se_4", # IRE1aKO original single end RNAseq (batch 1)
                "WT_poly_1", "WT_poly_2", # WT first polysome samples (batch 2)
                "WT_poly_3.1",  "WT_poly_3.2",  # WT polysome heavy & light merged , sample 1, technical replicates 1 & 2 (batch 3)
                "WT_poly_4.1",  "WT_poly_4.2",  # WT polysome heavy & light merged , sample 2, technical replicates 1 & 2 (batch 3)
                "WT_poly_heavy_1.1",  "WT_poly_heavy_1.2",  # WT polysome heavy sample 1, technical replicates 1 & 2 (batch 3)
                "WT_poly_heavy_2.1",  "WT_poly_heavy_2.2",  # WT polysome heavy sample 2, technical replicates 1 & 2 (batch 3)
                "WT_poly_light_1.1",  "WT_poly_light_1.2", # WT polysome light sample 1, technical replicates 1 & 2 (batch 3)
                "WT_poly_light_2.1",  "WT_poly_light_2.2", # WT polysome light sample 2, technical replicates 1 & 2 (batch 3)
                "WT_total_se_1", "WT_total_se_2","WT_total_se_3","WT_total_se_4" # WT original single end RNAseq (batch 1)
  ),
  sample = c("IRE1aKO_poly_1", "IRE1aKO_poly_2", # IRE1aKO first polysome samples (batch 2)
                "IRE1aKO_poly_3", "IRE1aKO_poly_3", # IRE1aKO polysome heavy & light merged , sample 1, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_4", "IRE1aKO_poly_4", # IRE1aKO polysome heavy & light merged , sample 2 technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_5", "IRE1aKO_poly_5", # IRE1aKO polysome heavy & light merged , sample 3 technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_heavy_1", "IRE1aKO_poly_heavy_1", # IRE1aKO polysome heavy sample 1, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_heavy_2", "IRE1aKO_poly_heavy_2", # IRE1aKO polysome heavy sample 2, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_heavy_3", "IRE1aKO_poly_heavy_3", # IRE1aKO polysome heavy sample 3, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_light_1" ,"IRE1aKO_poly_light_1" , # IRE1aKO polysome light sample 1, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_light_2" ,"IRE1aKO_poly_light_2" , # IRE1aKO polysome light sample 2, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_poly_light_3", "IRE1aKO_poly_light_3", # IRE1aKO polysome light sample 3, technical replicates 1 & 2 (batch 3)
                "IRE1aKO_total_se_1","IRE1aKO_total_se_2","IRE1aKO_total_se_3", "IRE1aKO_total_se_4", # IRE1aKO original single end RNAseq (batch 1)
                "WT_poly_1", "WT_poly_2", # WT first polysome samples (batch 2)
                "WT_poly_3",  "WT_poly_3",  # WT polysome heavy & light merged , sample 1, technical replicates 1 & 2 (batch 3)
                "WT_poly_4",  "WT_poly_4",  # WT polysome heavy & light merged , sample 2, technical replicates 1 & 2 (batch 3)
                "WT_poly_heavy_1",  "WT_poly_heavy_1",  # WT polysome heavy sample 1, technical replicates 1 & 2 (batch 3)
                "WT_poly_heavy_2",  "WT_poly_heavy_2",  # WT polysome heavy sample 2, technical replicates 1 & 2 (batch 3)
                "WT_poly_light_1",  "WT_poly_light_1", # WT polysome light sample 1, technical replicates 1 & 2 (batch 3)
                "WT_poly_light_2",  "WT_poly_light_2", # WT polysome light sample 2, technical replicates 1 & 2 (batch 3)
                "WT_total_se_1", "WT_total_se_2","WT_total_se_3" ,"WT_total_se_4" # WT original single end RNAseq (batch 1)
  ),
  condition = c(rep("IRE1aKO.polysome",8),
                rep("IRE1aKO.heavy", 6), 
                rep("IRE1aKO.light", 6),
                rep("IRE1aKO.total", 4),
                rep("WT.polysome", 6),
                rep("WT.heavy", 4), 
                rep("WT.light", 4),
                rep("WT.total", 4)
  ),
  genotype = c(rep("IRE1aKO",24), rep("WT",18)),
  fraction = c(rep("Polysome", 8), rep("Polysome.heavy",6),rep("Polysome.light", 6), rep("Total",4), 
               rep("Polysome", 6), rep("Polysome.heavy",4), rep("Polysome.light",4), rep("Total",4)),
  batch = c(rep("b2", 2), # IRE1aKO first polysome samples (batch 2)
            rep("b3", 6), # IRE1aKO polysome heavy & light merged (batch 3)
            rep("b3", 12), # IRE1aKO polysome heavy & light individual (batch 3)
            rep("b1", 4), # IRE1aKO original single end RNAseq
            rep("b2", 2), # WT first polysome samples (batch 2)
            rep("b3", 4), # WT polysome heavy & light merged (batch 3)
            rep("b3", 8), # WT polysome heavy & light individual (batch 3)
            rep("b1", 4) # WToriginal single end RNAseq
  ),
  technical_replicate = c("1","1","1","2","1","2","1","2", #  IRE1aKO Polysomes
                          "1","2","1","2","1","2", # IRE1aKO polysome heavy
                          "1","2","1","2","1","2", # IRE1aKO polysome light
                          "1","1","1","1",# IRE1aKO total se
                          "1","1","1","2","1","2", # WT polysomes
                          "1","2","1","2", # WT polysomes heavy
                          "1","2","1","2", # WT polysomes light
                          "1","1","1","1") # WT total se
)

# super important for how contrasts work
metadata$batch = factor(metadata$batch, levels = c("b1","b2","b3"))
metadata$genotype = factor(metadata$genotype, levels = c("WT","IRE1aKO"))
metadata$fraction = factor(metadata$fraction, levels = c("Total","Polysome","Polysome.heavy","Polysome.light"))
metadata$condition = factor(metadata$condition, 
                            levels = c("WT.total","WT.polysome","WT.heavy","WT.light",
                                       "IRE1aKO.total","IRE1aKO.polysome", "IRE1aKO.heavy","IRE1aKO.light"))



```


Following mostly guide by Love et al for DTU, DTE DGE analysis:
https://f1001research.com/articles/7-952/v3

```{r importfiles}

library(tximport)
library(readr)

### Transcript annotation
gtf <- "~/My Drive/Bench/IRE1 Polysome Seq 2022/annotations/gencode.vM33.annotation.gtf"

txdb.filename <- "gencode.vM33.annotation.sqlite"

txdb <- makeTxDbFromGFF(gtf)

# We can use saveDb() to save the TxDb database (SQLite database) for later uses
#saveDb(txdb, txdb.filename)

# We can use loadDb() to use the TxDb database
#txdb <- loadDb(txdb.filename)


# Create a tx2gene dataframe 'txdf
library(GenomicFeatures)

txdf <- AnnotationDbi::select(txdb, keys(txdb, "GENEID"), "TXNAME", "GENEID")


### Salmon quant files
files <- file.path("salmon_quant", metadata$sample_id, "quant.sf")
names(files) <- list.files("salmon_quant")

txi <- tximport(files, type="salmon", txOut=TRUE, ignoreAfterBar = TRUE, # because salmon id has ENSMUST...|ENSMUSG...|genesymbol etc
      countsFromAbundance="scaledTPM", importer=read.delim) #,"dtuScaledTPM", tx2gene = txdf) 
cts <- txi$counts
cts <- cts[rowSums(cts) > 0,]

txdf <- txdf[match(rownames(cts),txdf$TXNAME),]
print("Can all TXNAME be matched?", quote = FALSE); all(rownames(cts) %in% txdf$TXNAME) # check if all can be mapped

counts <- data.frame(gene_id=txdf$GENEID,
                     feature_id=txdf$TXNAME,
                     cts)



########## Remove outliers from Counts & Metadata #########
drops <- c("IRE1aKO_total_se_3","WT_total_se_4")
counts <- counts[ , -which(names(counts) %in% drops) ]
metadata <- metadata[ !metadata$sample_id %in% drops , ]

counts$gene_id <- gsub(counts$gene_id, pattern="\\.[0-9]+$", replacement="") #remove suffixes so we can query biomart
# Lets annotate gene symbol so its included 
# Get mart
library(biomaRt)
ensembl <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

# Fetch gene symbols
genes <- getBM(attributes = c('ensembl_gene_id', 'external_gene_name', 'gene_biotype'), 
               filters = 'ensembl_gene_id', 
               values = unique(counts$gene_id), 
               mart = ensembl)

# Merge with original count data
counts <- merge(x = counts, y = genes, 
                 by.x = "gene_id", 
                 by.y = "ensembl_gene_id", 
                 all.x = TRUE)
library(dplyr)


counts$ensembl_gene_id <- counts$gene_id 
counts$gene_id <- counts$external_gene_name
counts <- counts %>% dplyr::select(gene_id, feature_id, ensembl_gene_id, external_gene_name, gene_biotype, everything())


###############################################################################################################

# Subset to protein coding genes only, (we want to look at splicing, it doesn't make sense to include lncRNA, we only lose power)
counts <- subset(counts, gene_biotype =="protein_coding")

###############################################################################################################
#Manually collapse technical replicates ### should be functionalized later
# Counts are TPM, and technical replicates normally have minor variation and show poison, and should thus be averaged

counts$IRE1aKO_poly_3 <- (counts$IRE1aKO_poly_3.1 + counts$IRE1aKO_poly_3.2 ) /2
counts$IRE1aKO_poly_4 <- (counts$IRE1aKO_poly_4.1 + counts$IRE1aKO_poly_4.2 ) /2
counts$IRE1aKO_poly_5 <- (counts$IRE1aKO_poly_5.1 + counts$IRE1aKO_poly_5.2 ) /2

counts$IRE1aKO_poly_heavy_1 <- (counts$IRE1aKO_poly_heavy_1.1 + counts$IRE1aKO_poly_heavy_1.2 ) /2
counts$IRE1aKO_poly_heavy_2 <- (counts$IRE1aKO_poly_heavy_2.1 + counts$IRE1aKO_poly_heavy_2.2 ) /2
counts$IRE1aKO_poly_heavy_3 <- (counts$IRE1aKO_poly_heavy_3.1 + counts$IRE1aKO_poly_heavy_3.2 ) /2

counts$IRE1aKO_poly_light_1 <- (counts$IRE1aKO_poly_light_1.1 + counts$IRE1aKO_poly_light_1.2 ) /2
counts$IRE1aKO_poly_light_2 <- (counts$IRE1aKO_poly_light_2.1 + counts$IRE1aKO_poly_light_2.2 ) /2
counts$IRE1aKO_poly_light_3 <- (counts$IRE1aKO_poly_light_3.1 + counts$IRE1aKO_poly_light_3.2 ) /2

counts$WT_poly_3 <- (counts$WT_poly_3.1 + counts$WT_poly_3.2 ) /2
counts$WT_poly_4 <- (counts$WT_poly_4.1 + counts$WT_poly_4.2 ) /2

counts$WT_poly_heavy_1 <- (counts$WT_poly_heavy_1.1 + counts$WT_poly_heavy_1.2 ) /2
counts$WT_poly_heavy_2 <- (counts$WT_poly_heavy_2.1 + counts$WT_poly_heavy_2.2 ) /2

counts$WT_poly_light_1 <- (counts$WT_poly_light_1.1 + counts$WT_poly_light_1.2 ) /2
counts$WT_poly_light_2 <- (counts$WT_poly_light_2.1 + counts$WT_poly_light_2.2 ) /2

# Remove original columns ending in .1 or .2
counts <- counts[ , -grep("\\.1$|\\.2$", names(counts))]
# reorder names
counts <- counts[, order(names(counts))]
# move gene cols to beginning again
counts <- counts %>% dplyr::select(gene_id, feature_id, ensembl_gene_id, external_gene_name, everything())

###############################################################################################################

# make a collapsed metadata 
metadata.original <- metadata
metadata <- metadata[metadata$technical_replicate =="1",]
metadata$sample_id <- metadata$sample 


```



Total RNAseq was single end and  Polysome fraction was paired end in different batches so it doesn't make sense to analyse them together. We are now going to split the counts and metadata by experiment so that they can be analysed as separate objects. Statistically its also better to just use whole polysome rather than using light and heavy fractions which only have two replicates.

```{r split}
####### Split off metadata & counts from total RNA seq experiment ###############
# Metadata, IRE1aKO_total_se_3 and WT_total_se_4 appear to be outliers, have much higher seq depth
metadata.se <- metadata[metadata$fraction == "Total",]
rownames(metadata.se) <- metadata.se$sample_id
#need to reset levels for condition, though we will only be using the genotype variable for testing
metadata.se$condition <- factor(metadata.se$condition, levels = c("WT.total","IRE1aKO.total"))
# Counts
counts.se <- counts[, c("gene_id","feature_id","external_gene_name","ensembl_gene_id",rownames(metadata.se) ) ]




######### Split off metadata & counts from Polysome RNA seq experiments #########
# Metadata
metadata.poly <- metadata[metadata$fraction == "Polysome" ,]
rownames(metadata.poly) <- metadata.poly$sample_id
#need to reset levels for condition, though we will only be using the genotype variable for testing
metadata.poly$condition <- factor(metadata.poly$condition, levels = c("WT.polysome", "IRE1aKO.polysome"))

# Counts
counts.poly <- counts[, c("gene_id","feature_id","external_gene_name","ensembl_gene_id",rownames(metadata.poly) ) ]


######### Split off metadata & counts from Polysome Heavy fraction RNA seq experiments
# Metadata
metadata.heavy <- metadata[metadata$fraction == "Polysome.heavy",]
rownames(metadata.heavy) <- metadata.heavy$sample_id
#need to reset levels for condition, though we will only be using the genotype variable for testing
metadata.heavy$condition <- factor(metadata.heavy$condition, levels = c("WT.heavy", "IRE1aKO.heavy"))
# Counts
counts.heavy <- counts[,c("gene_id","feature_id","external_gene_name","ensembl_gene_id",rownames(metadata.heavy) ) ]


######### Split off metadata & counts from Polysome light fraction RNA seq experiments
# Metadata
metadata.light <- metadata[metadata$fraction == "Polysome.light",]
rownames(metadata.light) <- metadata.light$sample_id
#need to reset levels for condition, though we will only be using the genotype variable for testing
metadata.light$condition <- factor(metadata.light$condition, levels = c("WT.light", "IRE1aKO.light"))
# Counts
counts.light <- counts[,c("gene_id","feature_id","external_gene_name","ensembl_gene_id",rownames(metadata.light) ) ]


plotMDS(counts[,5:length(counts)])
plotMDS(counts.se[,5:length(counts.se)])
plotMDS(counts.poly[,5:length(counts.poly)])
plotMDS(counts.heavy[,5:length(counts.heavy)])
plotMDS(counts.light[,5:length(counts.light)])


```



```{r prepare_drimseq_objects}

library(DRIMSeq)
###### TOTAL RNASEQ DRIMSEQ OBJECT
d.se <- dmDSdata(counts=counts.se, samples=metadata.se) # d is the imaginative name for our Drimseq oject
d.se

# Filter the data to remove lowly expressed transcripts 
# n should be number of samples, n.small, the smallest group
n <- length(counts.se) - 4
n.small <- 3
d.se <- dmFilter(d.se,
              min_samps_feature_expr=n.small, min_feature_expr=10,
              min_samps_feature_prop=n.small, min_feature_prop=0.1,
              min_samps_gene_expr=n, min_gene_expr=10)
d.se

# The dmDSdata object only contains genes that have more that one isoform, 
# which makes sense as we are testing for differential transcript usage. 
# We can find out how many of the remaining genes have N isoforms by tabulating 
# the number of times we see a gene ID, then tabulating the output again:
table(table(counts(d.se)$gene_id))

###### POLYSOME DRIMSEQ OBJECT

d.poly <- dmDSdata(counts=counts.poly, samples=metadata.poly) # d is the imaginative name for our Drimseq oject
d.poly 

# Filter the data to remove lowly expressed transcripts 
# n should be number of samples, n.small, the smallest group
n <- length(counts.poly) - 4
n.small <- 4
d.poly <- dmFilter(d.poly,
              min_samps_feature_expr=n.small, min_feature_expr=10,
              min_samps_feature_prop=n.small, min_feature_prop=0.1,
              min_samps_gene_expr=n, min_gene_expr=10)
d.poly

# The dmDSdata object only contains genes that have more that one isoform, 
# which makes sense as we are testing for differential transcript usage. 
# We can find out how many of the remaining genes have N isoforms by tabulating 
# the number of times we see a gene ID, then tabulating the output again:
table(table(counts(d.poly)$gene_id))

###### POLYSOME HEAVY DRIMSEQ OBJECT
d.heavy <- dmDSdata(counts=counts.heavy, samples=metadata.heavy) # d is the imaginative name for our Drimseq oject
d.heavy

# Filter the data to remove lowly expressed transcripts 
# n should be number of samples, n.small, the smallest group
n <- length(counts.heavy) -4
n.small <- 4
d.heavy <- dmFilter(d.heavy,
              min_samps_feature_expr=n.small, min_feature_expr=10,
              min_samps_feature_prop=n.small, min_feature_prop=0.1,
              min_samps_gene_expr=n, min_gene_expr=10)
d.heavy

# The dmDSdata object only contains genes that have more that one isoform, 
# which makes sense as we are testing for differential transcript usage. 
# We can find out how many of the remaining genes have N isoforms by tabulating 
# the number of times we see a gene ID, then tabulating the output again:
table(table(counts(d.heavy)$gene_id))

###### POLYSOME LIGHT DRIMSEQ OBJECT
d.light <- dmDSdata(counts=counts.light, samples=metadata.light) # d is the imaginative name for our Drimseq oject
d.light

# Filter the data to remove lowly expressed transcripts 
# n should be number of samples, n.small, the smallest group
n <- length(counts.light) - 4
n.small <- 4
d.light <- dmFilter(d.light,
              min_samps_feature_expr=n.small, min_feature_expr=10,
              min_samps_feature_prop=n.small, min_feature_prop=0.1,
              min_samps_gene_expr=n, min_gene_expr=10)
d.light

# The dmDSdata object only contains genes that have more that one isoform, 
# which makes sense as we are testing for differential transcript usage. 
# We can find out how many of the remaining genes have N isoforms by tabulating 
# the number of times we see a gene ID, then tabulating the output again:
table(table(counts(d.light)$gene_id))


```



```{r DTUTesting_DRIMSEQ}
# Set multiple cores for parallel processing
BPPARAM <- BiocParallel::MulticoreParam(10)

# Create a model matrix, similar to how you would for DESeq2
# For total RNAseq
design_full.se <- model.matrix(~genotype, data=DRIMSeq::samples(d.se))
colnames(design_full.se)
d.se <- dmPrecision(d.se, design=design_full.se, BPPARAM = BPPARAM)
d.se <- dmFit(d.se, design=design_full.se)
d.se <- dmTest(d.se, coef="genotypeIRE1aKO")

# For Polysome RNAseq
design_full.poly <- model.matrix(~batch + genotype, data=DRIMSeq::samples(d.poly))
colnames(design_full.poly)
d.poly <- dmPrecision(d.poly, design=design_full.poly, BPPARAM = BPPARAM)
d.poly <- dmFit(d.poly, design=design_full.poly)
d.poly <- dmTest(d.poly, coef="genotypeIRE1aKO")

# For Polysome heavy RNAseq
design_full.heavy <- model.matrix(~genotype, data=DRIMSeq::samples(d.heavy))
colnames(design_full.heavy)
d.heavy <- dmPrecision(d.heavy, design=design_full.heavy, BPPARAM = BPPARAM)
d.heavy <- dmFit(d.heavy, design=design_full.heavy)
d.heavy <- dmTest(d.heavy, coef="genotypeIRE1aKO")

# For Polysome light RNAseq
design_full.light <- model.matrix(~genotype, data=DRIMSeq::samples(d.light))
colnames(design_full.light)
d.light <- dmPrecision(d.light, design=design_full.light, BPPARAM = BPPARAM)
d.light <- dmFit(d.light, design=design_full.light)
d.light <- dmTest(d.light, coef="genotypeIRE1aKO")



# Extract results for all tests
se.res <- DRIMSeq::results(d.se)
head(se.res) 
se.res.txp <- DRIMSeq::results(d.se, level="feature")
head(se.res.txp)

poly.res <- DRIMSeq::results(d.poly)
head(poly.res)
poly.res.txp <- DRIMSeq::results(d.poly, level="feature")
head(poly.res.txp)

heavy.res <- DRIMSeq::results(d.heavy)
head(heavy.res)
heavy.res.txp <- DRIMSeq::results(d.heavy, level="feature")
head(heavy.res.txp)

light.res <- DRIMSeq::results(d.light)
head(light.res)
light.res.txp <- DRIMSeq::results(d.light, level="feature")
head(light.res.txp)

save.image(file = "IRE1aDRIMseqDTU.Rdata")

```


```{r plot_DRIMSEQ_DTU}

no.na <- function(x) ifelse(is.na(x), 1, x)

# Single end total RNASeq
se.res$pvalue <- no.na(se.res$pvalue)
se.res.txp$pvalue <- no.na(se.res.txp$pvalue)
se.idx <- which(se.res$adj_pvalue < 0.05)[1]
se.res[se.idx,]

plotProportions(d.se, se.res$gene_id[se.idx], "condition")

# All Polysome
poly.res$pvalue <- no.na(poly.res$pvalue)
poly.res.txp$pvalue <- no.na(poly.res.txp$pvalue)
poly.idx <- which(poly.res$adj_pvalue < 0.05)[1]
poly.res[poly.idx,]

plotProportions(d.poly, poly.res$gene_id[poly.idx], "condition")

# Polysome Heavy Fraction
heavy.res$pvalue <- no.na(heavy.res$pvalue)
heavy.res.txp$pvalue <- no.na(heavy.res.txp$pvalue)
heavy.idx <- which(heavy.res$adj_pvalue < 0.05)[1]
heavy.res[heavy.idx,]

plotProportions(d.heavy, heavy.res$gene_id[heavy.idx], "condition")

# Polysome Light Fraction
light.res$pvalue <- no.na(light.res$pvalue)
light.res.txp$pvalue <- no.na(light.res.txp$pvalue)
light.idx <- which(light.res$adj_pvalue < 0.05)[1]
light.res[poly.idx,]

plotProportions(d.light, light.res$gene_id[light.idx], "condition")





```
# Two stage filtering

From Love et al (2018): "A typical analysis of differential transcript usage would involve asking first: “which genes contain any evidence of DTU?”, and secondly, “which transcripts in the genes that contain some evidence may be participating in the DTU?” Note that a gene may pass the first stage without exhibiting enough evidence to identify one or more transcripts that are participating in the DTU. The stageR package is designed to allow for such two-stage testing procedures, where the first stage is called a screening stage and the second stage a confirmation stage12. The methods are general, and can also be applied to testing, for example, changes across a time series followed by investigation of individual time points, as shown in the stageR package vignette. We show below how stageR is used to detect DTU and how to interpret its output."



```{r StageR}

# Function to prepare data for StageR:

ALPHA = 0.05
prep_and_StageR <- function(res, res.txp, prefix) {
  
  prepare_data <- function(res, res.txp, prefix) {
    # Ensure that 'res' has the required columns
    if (!all(c("pvalue", "gene_id") %in% names(res))) {
      stop("Input 'res' must have 'pvalue' and 'gene_id' columns.")
    }
    
    # Ensure that 'res.txp' has the required columns
    if (!all(c("pvalue", "feature_id", "gene_id") %in% names(res.txp))) {
      stop("Input 'res.txp' must have 'pvalue', 'feature_id', and 'gene_id' columns.")
    }
    
    # Extract and name pScreen from 'res'
    pScreen <- res$pvalue
    names(pScreen) <- res$gene_id
    
    # Create Confirmation matrix from 'res.txp'
    Confirmation <- matrix(res.txp$pvalue, ncol=1)
    rownames(Confirmation) <- gsub(res.txp$feature_id, pattern="\\.[0-9]+$", replacement="")
    
    # Arrange tx2gene data.frame
    tx2gene <- res.txp[,c("feature_id", "gene_id")]
    tx2gene$feature_id <- gsub(tx2gene$feature_id, pattern="\\.[0-9]+$", replacement="")
    
    # Return a list containing the three transformed objects, named with prefix
    output <- list(pScreen = pScreen, Confirmation = Confirmation, tx2gene = tx2gene)
    names(output) <- paste0(prefix, ".", names(output))
    
    return(output)
  }
  
  calculate_drim_padj <- function(pScreen, pConfirmation, prefix, tx2gene) {
    # Check if necessary libraries are installed
    if (!requireNamespace("stageR", quietly = TRUE)) {
      stop("You need to install the 'stageR' package")
    }
    
    # Load the library
    library(stageR)
    
    # Stage wise adjustment
    stageRObj <- stageRTx(pScreen = pScreen, pConfirmation = pConfirmation,
                          pScreenAdjusted = FALSE, tx2gene = tx2gene)
    stageRObj <- stageWiseAdjustment(stageRObj, method = "dtu", alpha = ALPHA)
    
    # Get adjusted p values and suppress warnings
    drim_padj <- suppressWarnings({
      getAdjustedPValues(stageRObj, order = FALSE,
                         onlySignificantGenes = TRUE)
    })
    
    # Form output
    output_name <- paste(prefix, "drim.padj", sep = ".")
    assign(output_name, drim_padj, envir = .GlobalEnv)
    
    return(drim_padj)
  }
  
  # First function execution
  prepared_data <- prepare_data(res = res, res.txp = res.txp, prefix = prefix)
  
  # Extract the relevant results from prepared_data
  pScreen <- prepared_data[[paste0(prefix, ".pScreen")]]
  pConfirmation <- prepared_data[[paste0(prefix, ".Confirmation")]]
  tx2gene <- prepared_data[[paste0(prefix, ".tx2gene")]]
  
  # Second function execution
  drim_padj <- calculate_drim_padj(
    pScreen = pScreen, 
    pConfirmation = pConfirmation, 
    prefix = prefix, 
    tx2gene = tx2gene
  )
  
  # Optionally return everything in a list for further use
  results <- c(prepared_data, list(drim.padj = drim_padj))
  return(results)
}

# this function will output a prefix.drim.padj object
prep_and_StageR(res = se.res, res.txp=se.res.txp, prefix = "se")
prep_and_StageR(res = poly.res, res.txp=poly.res.txp, prefix = "poly")
prep_and_StageR(res = heavy.res, res.txp=heavy.res.txp, prefix = "heavy")
prep_and_StageR(res = light.res, res.txp=light.res.txp, prefix = "light")

top_gene_id <- 
poly.res <- poly.res[order(poly.res$pvalue, decreasing = FALSE), ]
top_gene_id <- "Ern1"
plotProportions(d.poly, gene_id = top_gene_id, "genotype", plot_type= "boxplot2")


save.image(file = "IRE1aDRIMseqDTU.Rdata")
```



```{r DTU_DEXseq}
library(DEXSeq)
# For total RNAseq, could start from original count table but we will take from drimseq object 
sample.data.se <- DRIMSeq::samples(d.se)
count.data.se <- round(as.matrix(counts(d.se)[,-c(1:2)]))
dxd.se <- DEXSeqDataSet(countData=count.data.se,
                       sampleData=sample.data.se,
                       design=~sample + exon + genotype:exon,
                       featureID=counts(d.se)$feature_id,
                       groupID=counts(d.se)$gene_id)
dxd.se <- estimateSizeFactors(dxd.se)
dxd.se <- estimateDispersions(dxd.se, quiet=TRUE, BPPARAM = BPPARAM)
dxd.se <- testForDEU(dxd.se, reducedModel=~sample + exon, BPPARAM = BPPARAM)
dxr.se <- DEXSeqResults(dxd.se, independentFiltering=FALSE)
qval.se <- perGeneQValue(dxr.se)
dxr.g.se <- data.frame(gene=names(qval.se),qval.se)
dxr.t.se = as.data.frame(dxr.se[, c("featureID","groupID","pvalue")])
print(paste("In total RNAseq, found evidence of ", dim(dxr.g.se[dxr.g.se$qval < 0.05,])[1], "genes with isoform switching involving ", dim(dxr.se[dxr.se$padj < 0.05,])[1], "transcripts." ))

# Poly
sample.data.poly <- DRIMSeq::samples(d.poly)
count.data.poly <- round(as.matrix(counts(d.poly)[,-c(1:2)]))
dxd.poly <- DEXSeqDataSet(countData=count.data.poly,
                       sampleData=sample.data.poly,
                       design=~sample + batch + exon + genotype:exon,
                       featureID=counts(d.poly)$feature_id,
                       groupID=counts(d.poly)$gene_id)
dxd.poly <- estimateSizeFactors(dxd.poly)
dxd.poly <- estimateDispersions(dxd.poly, quiet=TRUE, BPPARAM = BPPARAM)
dxd.poly <- testForDEU(dxd.poly, reducedModel=~sample + batch + exon , BPPARAM = BPPARAM)
dxr.poly <- DEXSeqResults(dxd.poly, independentFiltering=FALSE)
qval.poly <- perGeneQValue(dxr.poly)
dxr.g.poly <- data.frame(gene=names(qval.poly),qval.poly)
dxr.t.poly = as.data.frame(dxr.poly[, c("featureID","groupID","pvalue")])
print(paste("In polysome fraction, found evidence of ", dim(dxr.g.poly[dxr.g.poly$qval < 0.05,])[1], "genes with isoform switching involving ", dim(dxr.poly[dxr.poly$padj < 0.05,])[1], "transcripts." ))

# Poly heavy
sample.data.heavy <- DRIMSeq::samples(d.heavy)
count.data.heavy <- round(as.matrix(counts(d.heavy)[,-c(1:2)]))
dxd.heavy <- DEXSeqDataSet(countData=count.data.heavy,
                       sampleData=sample.data.heavy,
                       design=~sample + exon + genotype:exon,
                       featureID=counts(d.heavy)$feature_id,
                       groupID=counts(d.heavy)$gene_id)
dxd.heavy <- estimateSizeFactors(dxd.heavy)
dxd.heavy <- estimateDispersions(dxd.heavy, quiet=TRUE, BPPARAM = BPPARAM)
dxd.heavy <- testForDEU(dxd.heavy, reducedModel=~sample + exon, BPPARAM = BPPARAM)
dxr.heavy <- DEXSeqResults(dxd.heavy, independentFiltering=FALSE)
qval.heavy <- perGeneQValue(dxr.heavy)
dxr.g.heavy<- data.frame(gene=names(qval.heavy),qval.heavy)
dxr.t.heavy = as.data.frame(dxr.heavy[, c("featureID","groupID","pvalue")])
print(paste("In polysome heavy fraction, found evidence of ", dim(dxr.g.heavy[dxr.g.heavy$qval < 0.05,])[1], "genes with isoform switching involving ", dim(dxr.heavy[dxr.heavy$padj < 0.05,])[1], "transcripts." ))

# Poly light
sample.data.light <- DRIMSeq::samples(d.light)
count.data.light <- round(as.matrix(counts(d.light)[,-c(1:2)]))
dxd.light <- DEXSeqDataSet(countData=count.data.light,
                       sampleData=sample.data.light,
                       design=~sample + exon + genotype:exon,
                       featureID=counts(d.light)$feature_id,
                       groupID=counts(d.light)$gene_id)
dxd.light <- estimateSizeFactors(dxd.light)
dxd.light <- estimateDispersions(dxd.light, quiet=TRUE, BPPARAM = BPPARAM)
dxd.light <- testForDEU(dxd.light, reducedModel=~sample + exon, BPPARAM = BPPARAM)
dxr.light <- DEXSeqResults(dxd.light, independentFiltering=FALSE)
qval.light <- perGeneQValue(dxr.light)
dxr.g.light <- data.frame(gene=names(qval.light),qval.light)
dxr.t.light = as.data.frame(dxr.light[, c("featureID","groupID","pvalue")])
print(paste("In polysome light fraction, found evidence of ", dim(dxr.g.light[dxr.g.light$qval < 0.05,])[1], "genes with isoform switching involving ", dim(dxr.light[dxr.light$padj < 0.05,])[1], "transcripts." ))



```

```{r stageR_DEXSEQ}



```


```{r DESEQ2_DGE}
# import with tximport and then convert transcripts to genes, which also calculates an average length per gene
# First subset files to remove outliers so it matches the filtered metadata, also subset to protein coding
files.sub <- files[-which(names(files) %in% drops) ]

files.poly <- subset(files.sub, names(files) %in% metadata.original[metadata.original$fraction %in% c("Polysome","Polysome.heavy","Polysome.light"),]$sample_id)

# from https://rdrr.io/github/bryancquach/omixjutsu/src/R/dge_utils.R
subset_txi <- function(txi, ids, dimension) {
  if (!dimension %in% c(1, 2)) {
    stop("Error: 'dimension' must be '1' (row) or '2' (column)")
  }
  index <- ids
  if (is.factor(index)) {
    index <- as.character(index)
  }
  if (is.character(index)) {
    if (dimension == 1) {
      if (sum(rownames(txi$counts) %in% index) != length(index)) {
        stop("IDs missing from txi object")
      }
      index <- match(x = index, table = rownames(txi$counts))
    } else {
      if (sum(colnames(txi$counts) %in% index) != length(index)) {
        stop("IDs missing from txi object")
      }
      index <- match(x = index, table = colnames(txi$counts))
    }
  }
  txi_subset <- txi
  if (dimension == 1) {
    txi_subset$counts <- txi_subset$counts[index, ]
    txi_subset$abundance <- txi_subset$abundance[index, ]
    txi_subset$length <- txi_subset$length[index, ]
  } else {
    txi_subset$counts <- txi_subset$counts[, index]
    txi_subset$abundance <- txi_subset$abundance[, index]
    txi_subset$length <- txi_subset$length[, index]
  }
  return(txi_subset)
}


txi.all <- tximport(files.sub, type="salmon", tx2gene=txdf[,2:1], ignoreAfterBar=TRUE, importer=read.delim, countsFromAbundance = "lengthScaledTPM")
# trim suffixes so we can subset correctly
rownames(txi.all$counts) <- sub("\\..*", "", rownames(txi.all$counts))

#######################################################################################################
# Subset to protein coding genes, using rownames from previously subset counts
txi.all <- subset_txi(txi.all, ids= unique(counts$ensembl_gene_id), dimension=1)
#######################################################################################################


txi.poly <- tximport(files.poly, type="salmon", tx2gene=txdf[,2:1], ignoreAfterBar=TRUE, importer=read.delim, countsFromAbundance = "lengthScaledTPM")
# trim suffixes so we can subset correctly
rownames(txi.poly$counts) <- sub("\\..*", "", rownames(txi.poly$counts))

#######################################################################################################

# Subset to protein coding genes, using rownames from previously subset counts
txi.poly <- subset_txi(txi.poly, ids= unique(counts$ensembl_gene_id), dimension=1)

#######################################################################################################

# Main dds object with batch included in design
dds <- DESeqDataSetFromTximport(txi.all, metadata.original, ~batch + genotype, )
keep <- rowSums(counts(dds) >= 10) >= 3
dds <- dds[keep,]
dds <- collapseReplicates(dds, dds$sample, dds$technical_replicate )

# Main dds object from poly with batch and fraction included in design
dds.poly.all <- DESeqDataSetFromTximport(txi.poly, metadata.original[metadata.original$fraction %in% c("Polysome","Polysome.heavy","Polysome.light"),], ~batch + fraction + genotype)
keep <- rowSums(counts(dds.poly.all) >= 10) >= 3
dds.poly.all <- dds.poly.all[keep,]
dds.poly.all <- collapseReplicates(dds.poly.all, dds.poly.all$sample, dds.poly.all$technical_replicate )


# Main dds object with batch ommited from design 
dds.nobatch <- DESeqDataSetFromTximport(txi.all, metadata.original, ~genotype)
keep <- rowSums(counts(dds.nobatch) >= 10) >= 3
dds.nobatch <- dds.nobatch[keep,]
dds.nobatch <- collapseReplicates(dds.nobatch, dds.nobatch$sample, dds.nobatch$technical_replicate )

# Total RNAseq
dds.se <- dds.nobatch[,dds.nobatch$fraction == "Total"]

# Polysome
dds.poly <-  dds[,dds$fraction == "Polysome"]
dds.poly$batch <- factor(dds.poly$batch, levels = c("b2","b3")) #because batch 1 gets dropped need to fix levels

#Polysome Batch 3 only
dds.poly.b3 <-  dds.nobatch[,dds.nobatch$batch == "b3" & dds.nobatch$fraction == "Polysome"]
dds.poly.b3$batch <- factor(dds.poly.b3$batch, levels = c("b3")) #because batch 1 & 2 get dropped need to fix levels

#Polysome Heavy
dds.heavy <-  dds.nobatch[,dds.nobatch$fraction == "Polysome.heavy"]

#Polysome Light
dds.light <-  dds.nobatch[,dds.nobatch$fraction == "Polysome.light"]


dds <- DESeq(dds, parallel=TRUE)
dds.se <- DESeq(dds.se, parallel=TRUE,)
dds.poly.all <- DESeq(dds.poly.all, parallel=TRUE)
dds.poly <- DESeq(dds.poly, parallel=TRUE)
dds.poly.b3 <- DESeq(dds.poly.b3, parallel=TRUE)
dds.heavy <- DESeq(dds.heavy, parallel=TRUE)
dds.light <- DESeq(dds.light, parallel=TRUE)


res.dds <- DESeq2::results(dds, name = "genotype_IRE1aKO_vs_WT")
res.dds.LFC <- lfcShrink(dds, coef="genotype_IRE1aKO_vs_WT", type="apeglm")
DESeq2::plotMA(res.dds, ylim=c(-2,2)) 
DESeq2::plotMA(res.dds.LFC, ylim=c(-2,2))

res.dds.se <- DESeq2::results(dds.se, name = "genotype_IRE1aKO_vs_WT")
DESeq2::plotMA(res.dds.se, ylim=c(-2,2)) 
res.dds.se.LFC <- lfcShrink(dds.se, coef="genotype_IRE1aKO_vs_WT", type="apeglm")
DESeq2::plotMA(res.dds.LFC, ylim=c(-2,2))

res.dds.poly.all <- DESeq2::results(dds.poly.all, name = "genotype_IRE1aKO_vs_WT")
DESeq2::plotMA(res.dds.poly.all, ylim=c(-2,2)) 
res.dds.poly.all.LFC <- lfcShrink(dds.poly.all, coef="genotype_IRE1aKO_vs_WT", type="apeglm")
DESeq2::plotMA(res.dds.poly.all.LFC, ylim=c(-2,2))

res.dds.poly <- DESeq2::results(dds.poly, name = "genotype_IRE1aKO_vs_WT")
DESeq2::plotMA(res.dds.poly, ylim=c(-2,2)) 
res.dds.poly.LFC <- lfcShrink(dds.poly, coef="genotype_IRE1aKO_vs_WT", type="apeglm")
DESeq2::plotMA(res.dds.poly.LFC, ylim=c(-2,2))

res.dds.poly.b3 <- DESeq2::results(dds.poly.b3, name = "genotype_IRE1aKO_vs_WT")
DESeq2::plotMA(res.dds, ylim=c(-2,2))
DESeq2::plotMA(res.dds.LFC, ylim=c(-2,2))

res.dds.heavy <- DESeq2::results(dds.heavy, name = "genotype_IRE1aKO_vs_WT")
res.dds.light <- DESeq2::results(dds.light, name = "genotype_IRE1aKO_vs_WT")


```

```{r heatmap_DGE}
#annotate DESEQ2 results tables
library(biomaRt)

# Use biomaRt to get external gene names
getGeneNames <- function(ensembl_ids) {
    # Remove the suffixes
    ensembl_ids <- gsub("\\..*", "", ensembl_ids)
    mart <- useMart(biomart = "ensembl", dataset = "mmusculus_gene_ensembl")
    genes <- getBM(attributes = c('ensembl_gene_id', 'external_gene_name','gene_biotype'), 
                   filters = 'ensembl_gene_id', 
                   values = ensembl_ids, 
                   mart = mart)
    return(genes)
}


addGeneNamesToRes <- function(res) {
    gene_info <- getGeneNames(rownames(res))
    res$ensembl_gene_id <- gsub("\\..*", "", rownames(res)) # Remove suffixes for merging
    merged <- merge(res, gene_info, by = "ensembl_gene_id", all.x = TRUE)
    rownames(merged) <- merged$ensembl_gene_id
    merged$ensembl_gene_id <- NULL
    return(merged)
}


res.dds <- addGeneNamesToRes(as.data.frame(res.dds))
res.dds.se <- addGeneNamesToRes(as.data.frame(res.dds.se))
res.dds.poly.all <- addGeneNamesToRes(as.data.frame(res.dds.poly.all))
res.dds.poly <- addGeneNamesToRes(as.data.frame(res.dds.poly))
res.dds.poly.b3 <- addGeneNamesToRes(as.data.frame(res.dds.poly.b3))
res.dds.heavy <- addGeneNamesToRes(as.data.frame(res.dds.heavy))
res.dds.light <- addGeneNamesToRes(as.data.frame(res.dds.light))


# extract significant genes from each test

extractSignificantGenes <- function(res, padj_threshold = 0.05, lfcthreshold = 0.5) {
    significant_genes <- subset(res, padj < padj_threshold & 
                                  abs(log2FoldChange) > lfcthreshold 
                                ) 
    return(data.frame(ensembl_id = rownames(significant_genes), 
                      external_gene_name = significant_genes$external_gene_name))
}

extractSignificantGenesPC <- function(res, padj_threshold = 0.1, lfcthreshold = 0.3) {
    significant_genes <- subset(res, padj < padj_threshold & 
                                  abs(log2FoldChange) > lfcthreshold &
                                  gene_biotype == "protein_coding")
    return(data.frame(ensembl_id = rownames(significant_genes), 
                      external_gene_name = significant_genes$external_gene_name))
}



poly.all = extractSignificantGenes(res.dds.poly.all)
poly.all.pc = extractSignificantGenesPC(res.dds.poly.all)

# This will now generate a list of data frames, with both IDs
list_significant_genes <- list( 
  all = extractSignificantGenes(res.dds),
  se = extractSignificantGenes(res.dds.se),
  poly.all = extractSignificantGenes(res.dds.poly.all),
  poly = extractSignificantGenes(res.dds.poly),
  poly.b3 = extractSignificantGenes(res.dds.poly.b3),
  heavy = extractSignificantGenes(res.dds.heavy),
  light = extractSignificantGenes(res.dds.light)
)


sig.list <- bind_rows(list_significant_genes) %>% distinct()
sig.poly.nolightheavy <- bind_rows(list_significant_genes$poly.all)
sig.poly <- bind_rows(list_significant_genes$poly.all, list_significant_genes$heavy, list_significant_genes$light, list_significant_genes$poly.b3) %>% distinct()




library(DESeq2)
library(limma)
library(ComplexHeatmap)

```

```{r oneheat}

### HEATMAP WITH ALL #####
dds.heat <-  dds

#Because we stripped ensembl_id suffixes above, we have to do the same in the dds object to match them
# original_rownames <- rownames(dds.heat) #save them in case needed
# rownames(dds.heat) <- gsub("\\..*", "", rownames(dds.heat))

# Subset VST-transformed data to only include the significant genes
vst_data <- assay(vst(dds.heat))
vst_data <- vst_data[sig.list$ensembl_id, ]

# Replace the rownames of the matrix with external gene name
rownames(vst_data) <- sig.list$external_gene_name

metadata.collapsed <- metadata[metadata$technical_replicate =="1",]
metadata.collapsed$sample_id <- metadata.collapsed$sample 

# Remove batch effect
vst_nobatch <- removeBatchEffect(vst_data, batch=metadata.collapsed$batch)

# Scale the data
mat <- t(scale(t(vst_nobatch), scale = T))

# Ensure the columns in metadata correspond to the columns in the expression data
col_order <- colnames(mat)

metadata.collapsed <- metadata.collapsed[match(col_order, metadata.collapsed$sample_id), ]
metadata.collapsed.trim <- subset(metadata.collapsed, select= -c(sample_id, sample))

# Prepare annotations for the heatmap
ha = HeatmapAnnotation(df = metadata.collapsed.trim)

# Plot the heatmap
heatmap = Heatmap(
  mat,
  name = "Expression",
  top_annotation = ha,
  row_names_gp = grid::gpar(fontsize = 5),
  show_row_names = FALSE
)

draw(heatmap)

```

```{r poly.all.heat}

######## Lets do it without total RNAseq, with collapsed technical replicates, where batch and fraction are included in design and in removeBatchEffect for matrix preparation collapsed technical replicates ###############
dds.heat.b <-  dds.poly.all

#Because we stripped ensembl_id suffixes above, we have to do the same in the dds object to match them
original_rownames.b <- rownames(dds.heat.b) #save them in case needed
rownames(dds.heat.b) <- gsub("\\..*", "", rownames(dds.heat.b))

# Subset VST-transformed data to only include the significant genes
vst_data.b <- assay(vst(dds.heat.b))
vst_data.b <- vst_data.b[sig.poly$ensembl_id, ]

# Replace the rownames of the matrix with external gene name
rownames(vst_data.b) <- sig.poly$external_gene_name

#create subset of metadata without total RNASeq
metadata_ordered.b <- metadata[metadata$batch %in% c("b2","b3") & metadata$technical_replicate =="1",]

metadata_ordered.b$batch <- factor(metadata_ordered.b$batch, levels = c("b2","b3")) 
metadata_ordered.b$fraction <- factor(metadata_ordered.b$fraction, levels = c("Polysome","Polysome.heavy","Polysome.light")) 
metadata_ordered.b$sample_id <- metadata_ordered.b$sample

# Remove fraction effect effect
vst_nobatch.b <- removeBatchEffect(vst_data.b, batch=metadata_ordered.b$batch)

# Scale the data
mat.b <- t(scale(t(vst_nobatch.b)))

# Ensure the columns in metadata correspond to the columns in the expression data
col_order.b <- colnames(mat.b)
metadata_ordered.b <- metadata_ordered.b[match(col_order.b, metadata_ordered.b$sample_id), ]
metadata_ordered.b <- subset(metadata_ordered.b, select= -c(sample_id, sample, technical_replicate, condition))




# Prepare annotations for the heatmap
ha.b = HeatmapAnnotation(df = metadata_ordered.b)

require(circlize)
require(RColorBrewer)
require(cluster)
pamClusters <- cluster::pam(mat.b, k = 4) # pre-select k = 4 centers
pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)

# fix order of the clusters to have 1 to 4, top to bottom
pamClusters$clustering <- factor(pamClusters$clustering, levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4'))

myCol <- colorRampPalette(c('dodgerblue', 'black', 'yellow'))(100)
myBreaks <- seq(-3, 3, length.out = 100)

# 'Step through' gene annotations to only label every 10th row
genelabels <- rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(mat.b), 2),
      labels = rownames(mat.b)[seq(1, nrow(mat.b), 2)],
      labels_gp = gpar(fontsize = 8, fontface = 'bold'),
      padding = 0.5),
      width = unit(2.0, 'cm') +

      max_text_width(
        rownames(mat.b)[seq(1, nrow(mat.b), 2)],
        gp = gpar(fontsize = 15,  fontface = 'bold')))


# Plot the heatmap
heatmap.b = Heatmap(
  mat.b,
  #split the genes / rows according to the PAM clusters
  # split = pamClusters$clustering,
  # cluster_row_slices = FALSE,
  name = 'Gene\nZ-\nscore', 
  col = colorRamp2(myBreaks, myCol),
  top_annotation = ha.b,
  # row (gene) parameters
  cluster_rows = TRUE,
  show_row_dend = TRUE,
  #row_title = 'Statistically significant genes',
  row_title_side = 'left',
  row_title_gp = gpar(fontsize = 12,  fontface = 'bold'),
  row_title_rot = 90,
  row_names_gp = gpar(fontsize = 15, fontface = 'bold'),
  row_names_side = 'left',
  row_dend_width = unit(25,'mm'),
  show_row_names = FALSE,
  # cluster methods for rows and columns
  clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
  clustering_method_columns = 'ward.D2',
  clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
  clustering_method_rows = 'ward.D2',
  show_column_names = FALSE,
)

pdf(file ="~/My Drive/Bench/IRE1 Polysome Seq 2022/plots/test_heatmap.pdf", width = 9, height = 10)
draw(heatmap.b+genelabels)

```

```{r volcano}
#Theres a handful of Ensembl ids that are gene duplicates, keep the ones with the highest counts
o <- order(res.dds.poly.all$baseMean, decreasing=TRUE)
res.dds.poly.all <- res.dds.poly.all[o,]
dups <- duplicated(res.dds.poly.all$external_gene_name)
res.dds.poly.all <- res.dds.poly.all[!dups,]


rownames(res.dds.poly.all) <- res.dds.poly.all$external_gene_name

library(EnhancedVolcano)
lab_italics = paste0("italic('", rownames(res.dds.poly.all), "')") 



pCutoff = 0.05
FCcutoff = 2.0

poly.all.volcano <- 
  EnhancedVolcano(res.dds.poly.all, 
                  lab = lab_italics, 
                  #selectLab = selectlabels_italic,
                  x = 'log2FoldChange', y = 'padj',
                  xlab = bquote(~Log[2]~ 'fold change'), 
                  ylab = bquote(~-Log[10]~adjusted~italic(P)),
                  boxedLabels = TRUE,
                  parseLabels = TRUE,
                  pCutoff = pCutoff, 
                  FCcutoff = FCcutoff, 
                  pointSize = 1.0, 
                  labSize = 3.0,
                  drawConnectors = TRUE,
                  widthConnectors = 0.5,
                  title = paste0("Differential Gene Expression in IRE1","\u03B1","KO Polysome RNA"),
                  subtitle = "...",
                  caption = paste0('log2 FC cutoff: ', 
                    FCcutoff, '; p-value cutoff: ', 
                    pCutoff, '\nTotal = ', 
                    
                    nrow(res.dds.poly.all), ' variables')
                  ) #+ coord_flip()#,
  #legend=c('NS','Log2 FC','Adjusted p-value', 'Adjusted p-value & Log2 FC'),
  #legendPosition = 'bottom', legendLabSize = 14, legendIconSize = 5.0)


poly.all.volcano









```

```{r other_heat}
######## Lets do it with polysomes heavy & light collapsed ###############
dds.heat.b3 <-  dds[,dds$fraction == "Polysome"]

#Because we stripped ensembl_id suffixes above, we have to do the same in the dds object to match them
original_rownames.b3 <- rownames(dds.heat.b3) #save them in case needed
rownames(dds.heat.b3) <- gsub("\\..*", "", rownames(dds.heat.b3))


# Subset VST-transformed data to only include the significant genes
vst_data.b3 <- assay(vst(dds.heat.b3))
vst_data.b3 <- vst_data.b3[sig.poly.nolightheavy$ensembl_id, ]

# Replace the rownames of the matrix with external gene name
rownames(vst_data.b3) <- sig.poly.nolightheavy$external_gene_name

#create subset of metadata without total RNASeq
metadata_ordered.b3 <- metadata[metadata$fraction == "Polysome" & metadata$technical_replicate =="1",]

metadata_ordered.b3$batch <- factor(metadata_ordered.b3$batch, levels = c("b2","b3")) 
metadata_ordered.b3$sample_id <- metadata_ordered.b3$sample

# Remove fraction effect effect
vst_nobatch.b3 <- removeBatchEffect(vst_data.b3, batch=metadata_ordered.b3$batch)
plotMDS(vst_nobatch.b3)
# Scale the data
mat.b3 <- t(scale(t(vst_nobatch.b3)))

# Ensure the columns in metadata correspond to the columns in the expression data
col_order.b3 <- colnames(mat.b3)
metadata_ordered.b3 <- metadata_ordered.b3[match(col_order.b3, metadata_ordered.b3$sample_id), ]
metadata_ordered.b3 <- subset(metadata_ordered.b3, select= -c(sample_id, sample))

# Prepare annotations for the heatmap
ha.b3 = HeatmapAnnotation(df = metadata_ordered.b3)

require(circlize)
require(RColorBrewer)
require(cluster)
pamClusters <- cluster::pam(mat.b3, k = 4) # pre-select k = 4 centers
pamClusters$clustering <- paste0('Cluster ', pamClusters$clustering)

# fix order of the clusters to have 1 to 4, top to bottom
pamClusters$clustering <- factor(pamClusters$clustering, levels = c('Cluster 1', 'Cluster 2', 'Cluster 3', 'Cluster 4'))

myCol <- colorRampPalette(c('dodgerblue', 'black', 'yellow'))(100)
myBreaks <- seq(-3, 3, length.out = 100)

# 'Step through' gene annotations to only label every 10th row
genelabels <- rowAnnotation(
    Genes = anno_mark(
      at = seq(1, nrow(mat.b3), 1),
      labels = rownames(mat.b3)[seq(1, nrow(mat.b3), 1)],
      labels_gp = gpar(fontsize = 8, fontface = 'bold'),
      padding = 0.5),
      width = unit(2.0, 'cm') +

      max_text_width(
        rownames(mat.b3)[seq(1, nrow(mat.b3), 1)],
        gp = gpar(fontsize = 15,  fontface = 'bold')))


# Plot the heatmap
heatmap.b3 = Heatmap(
  mat.b3,
  #split the genes / rows according to the PAM clusters
  # split = pamClusters$clustering,
  # cluster_row_slices = FALSE,
  name = 'Gene\nZ-\nscore', 
  col = colorRamp2(myBreaks, myCol),
  top_annotation = ha.b3,
  # row (gene) parameters
  cluster_rows = TRUE,
  show_row_dend = TRUE,
  #row_title = 'Statistically significant genes',
  row_title_side = 'left',
  row_title_gp = gpar(fontsize = 12,  fontface = 'bold'),
  row_title_rot = 90,
  row_names_gp = gpar(fontsize = 15, fontface = 'bold'),
  row_names_side = 'left',
  row_dend_width = unit(25,'mm'),
  show_row_names = FALSE,
  # cluster methods for rows and columns
  clustering_distance_columns = function(x) as.dist(1 - cor(t(x))),
  clustering_method_columns = 'ward.D2',
  clustering_distance_rows = function(x) as.dist(1 - cor(t(x))),
  clustering_method_rows = 'ward.D2',
  show_column_names = FALSE,
)

pdf(file ="~/My Drive/Bench/IRE1 Polysome Seq 2022/plots/test_heatmap.pdf", width = 9, height = 10)
draw(heatmap.b3+genelabels)



```

```{r volcano}
library(ggrepel)
library(ggplot2)
library(patchwork)

res.dds <- res.dds[!is.na(res.dds$padj) & res.dds$padj != 0, ]
res.dds.se <- res.dds.se[!is.na(res.dds.se$padj) & res.dds.se$padj != 0, ]
res.dds.poly <- res.dds.poly[!is.na(res.dds.poly$padj) & res.dds.poly$padj != 0, ]
res.dds.poly.all <- res.dds.poly.all[!is.na(res.dds.poly.all$padj) & res.dds.poly.all$padj != 0 & res.dds.poly.all$gene_biotype == "protein_coding"  , ]
res.dds.heavy <- res.dds.heavy[!is.na(res.dds.heavy$padj) & res.dds.heavy$padj != 0, ]
res.dds.light <- res.dds.light[!is.na(res.dds.light$padj) & res.dds.light$padj != 0, ]



plot_volcano <- function(res, title="", log2fc_threshold=0.5, padj_threshold=0.05, n_labels=35) {
    
    # Filter out NA values
    res <- res[!is.na(res$log2FoldChange) & !is.na(res$padj),]
    
    res$color <- "gray" # default color
    
    # Update condition to avoid NA values
    upregulated <- res$log2FoldChange > log2fc_threshold & res$padj < padj_threshold
    downregulated <- res$log2FoldChange < -log2fc_threshold & res$padj < padj_threshold
    
    res$color[upregulated] <- "blue"
    res$color[downregulated] <- "red"
    
    # Select top genes by absolute log2FC magnitude
    res.sub <- res[res$padj < padj_threshold,]
    top_genes <- res.sub[order(-abs(res.sub$log2FoldChange)),][1:n_labels,]
    
    max_abs_fc <- max(abs(res$log2FoldChange), na.rm = TRUE) + 0.5  # Adding a bit of padding
    
    p <- ggplot(res, aes(x=log2FoldChange, y=-log10(padj), color=color)) +
        geom_point(alpha=0.5) +
        theme_minimal() +
        coord_cartesian(xlim = c(-max_abs_fc, max_abs_fc), ylim = c(0, max(-log10(res$padj), na.rm = TRUE) + 1)) +
        labs(title=title, x="Log2 Fold Change", y="-Log10 Adjusted P-Value") +
        scale_color_identity() +
        geom_text_repel(data=top_genes,
                        aes(label=external_gene_name),
                        size=3, 
                        box.padding = 0.5,
                        point.padding = 0.5,
                        max.overlaps = 100)
    
    return(p)
}

plot_volcano(res.dds, "All Counts")
plot_volcano(res.dds.se, "Total RNAseq")
plot_volcano(res.dds.poly, "All Polysomes")
plot_volcano(res.dds.poly.all, "All Polysomes")
plot_volcano(res.dds.heavy, "Heavy Polysomes")
plot_volcano(res.dds.light, "Light Polysomes")


plots <- list(
    all = plot_volcano(res.dds, "All Counts"),
    se = plot_volcano(res.dds.se, "Total RNAseq"),
    poly = plot_volcano(res.dds.poly, "All Polysomes"),
    heavy = plot_volcano(res.dds.heavy, "Heavy Polysomes"),
    light = plot_volcano(res.dds.light, "Light Polysomes")
)


plots$all + plots$se + plots$poly + plots$heavy + plots$light + 
  plot_layout(ncol=2)




```
